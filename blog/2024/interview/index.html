<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>My interests are generative modeling based on physics and geometrical methods.</p> <p>This is primarily determined by recent advances in generative modeling. Specifically, framework of diffusion networks consisting of closely related markov chains, stochastic ode and langevin dynamics. I believe that solution for coherence of representation of long can be found via analysis through fundamental physics law of continuation and motion.</p> <p>Yandex has rich access to media data. computational resources and experience of developing diffusion networks as YandexART. I am looking for a guidance in writing top papers proposing new approaches.</p> <p>Dream Fusion: Text-to-3D using 2D Diffusion - Preprint https://arxiv.org/abs/2209.14988</p> <p>Artictle proposed a novel approach to text-to-3D synthesis by leveraging a pretrained 2D text-to-image diffusion model. Crucially, the proposed approach eliminates the need for labeled 3D training data and avoids modifications to the image diffusion model. The optimization involves refining a randomly-initialized 3D mode ) through gradient descent, ensuring low loss in its 2D renderings from random angles.</p> <hr> <p>Profilic dreamer: High-Fidelity and Diverse Text-to-3D Generation with Variational Score Distillation- https://arxiv.org/abs/2305.16213</p> <p>Authors proposed novel approach for distillation 2d diffusion text-to-image models to 3d. They elaborate previous technique SDS introduced in Dream Fusion(https://dreamfusion3d.github.io/) by building distribution of implicit representation rather making it constant. For facilitating computation they utilize particle-based variational inference. I get of method intuition through paper Understanding and Accelerating Particle-Based Variational Inference(https://arxiv.org/pdf/1807.01750.pdf). Despite time consuming inference fidelity approach is much better than competing works. Moreover model enjoy appropriate for diffusion models guidance scale around 10.</p> <p>Action Matching: Learning Stochastic Dynamics from Samples -https://arxiv.org/abs/2210.06662</p> <p>Action Matching addresses the challenge of learning the continuous dynamics of a system when only provided with snapshots of its temporal marginals. I believe that such approaches will help to build semantics of complex actions like.</p> <hr> <p>I gained great experience by building infrastructures for ML models, which can be easily modified via configs and command line interface. As for code preferences I prefer laconic style and enjoy usage of generator expressions where it possible. When possible I use task specific libraries as it helps concentrate on research task rather.</p> <p>Here’s representative example of ordering directed graph written in JSON</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># link has format [1,1,0,2,1,'.csv']
# link[0] - id of link (order of bringing links to folder)
# link[1] - id of source node
# link[3] - id of target node
# node.outputs contain use link id
# that's why we need link_map
# you can have better understanding looking at graph.json in test folder
</span>
<span class="c1"># Create a mapping of link IDs to their corresponding links
</span><span class="n">link_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">link</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">}</span>

<span class="c1"># Define a function to extract relevant IDs from a link
</span><span class="n">extract_ids</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">link_map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">link_map</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">3</span><span class="p">],)</span>

<span class="c1"># Create a dictionary mapping node links to their corresponding IDs
</span><span class="n">linkage</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">input</span><span class="p">.</span><span class="n">link</span><span class="p">:</span> <span class="nf">extract_ids</span><span class="p">(</span><span class="nb">input</span><span class="p">.</span><span class="n">link</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="nb">input</span> <span class="ow">in</span> <span class="n">node</span><span class="p">.</span><span class="n">inputs</span>
    <span class="k">if</span> <span class="nb">input</span><span class="p">.</span><span class="n">link</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="p">}</span>

<span class="c1"># Build a directed graph using NetworkX
</span><span class="n">dependency_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nc">DiGraph</span><span class="p">(</span><span class="n">linkage</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>

<span class="c1"># Group the generations of the DAG
</span><span class="n">grouped_dag</span> <span class="o">=</span> <span class="p">[</span><span class="nf">sorted</span><span class="p">(</span><span class="n">generation</span><span class="p">)</span> <span class="k">for</span> <span class="n">generation</span> <span class="ow">in</span> <span class="n">nx</span><span class="p">.</span><span class="nf">topological_generations</span><span class="p">(</span><span class="n">dependency_graph</span><span class="p">)]</span>
</code></pre></div></div> <p>Utilization of the “Don’t Repeat Yourself” (DRY) principle helped me a lot with learning benefits of abstractions, decomposing and code refactoring. You can see my progress in developing In my project multi-component projects here: https://github.com/NMashalov/PydanticGraph. In PydanticGraph i worked a lot with validation framework Pydantic. That brought me intuition of working with developer abstractions and python inner libraries like importlib.</p> </body></html>